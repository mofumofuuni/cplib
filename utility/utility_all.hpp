// Fast I/O, modint, mod998, segmenttree, lazysegtree, constant, functions, macro
namespace utility {static constexpr const unsigned int BUF_SIZE = 1 << 17;class Cinstream {private:using MyType = Cinstream;unsigned int p = BUF_SIZE;static char Q[BUF_SIZE];template <class T, int sp = 1>T nextUint() {if constexpr (sp) skipspace();T buf = 0;while (true) {char tmp = seekchar();if ('9' < tmp || tmp < '0') break;buf = buf * 10 + (tmp - '0');++p;}return buf;}public:char seekchar() {if (p == BUF_SIZE) {size_t len = fread(Q, 1, BUF_SIZE, stdin);if (len == 0) return '\0';if (len != BUF_SIZE) Q[len] = '\0';p = 0;}return Q[p];}void skipspace() { while (isspace(seekchar())) ++p; }uint32_t nextU32() { return nextUint<uint32_t>(); }int32_t nextI32() {skipspace();if (seekchar() == '-') { ++p; return (int32_t)(-nextUint<uint32_t, 0>()); }return (int32_t)nextUint<uint32_t, 0>();}uint64_t nextU64() { return nextUint<uint64_t>(); }int64_t nextI64() {skipspace();if (seekchar() == '-') { ++p; return (int64_t)(-nextUint<int64_t, 0>()); }return (int64_t)nextUint<int64_t, 0>();}template <class T>T nextInt() {skipspace();if (seekchar() == '-') { ++p; return -nextUint<T, 0>(); }return nextUint<T, 0>();}char nextchar() { skipspace(); char buf = seekchar(); ++p; return buf; }std::string nextToken() {skipspace();std::string buf;while (true) {char c = seekchar();if (isspace(c) || c == '\0') break;buf.push_back(c);++p;}return buf;}MyType& operator>>(int& dest) { dest = nextI32(); return *this; }MyType& operator>>(unsigned int& dest) { dest = nextU32(); return *this; }MyType& operator>>(long& dest) { dest = nextI64(); return *this; }MyType& operator>>(unsigned long& dest) { dest = nextU64(); return *this; }MyType& operator>>(long long& dest) { dest = nextI64(); return *this; }MyType& operator>>(unsigned long long& dest) { dest = nextU64(); return *this; }MyType& operator>>(std::string& dest) { dest = nextToken(); return *this; }MyType& operator>>(char& dest) { dest = nextchar(); return *this; }template <class T>MyType& operator>>(std::vector<T>& dest) {for (int i = 0; i < (int)dest.size(); ++i) (*this) >> dest[i];return *this;}} cin;struct fastoutputtable {char lz[1000][4] = {}, nlz[1000][4] = {};constexpr fastoutputtable() {using u32 = uint_fast32_t;for (u32 i = 0; i < 1000; ++i) {lz[i][0] = ('0' + i / 100 % 10);lz[i][1] = ('0' + i / 10 % 10);lz[i][2] = ('0' + i % 10);lz[i][3] = '\0';}for (u32 i = 0; i < 1000; ++i) {u32 j = 0;if (i >= 100) nlz[i][j++] = ('0' + i / 100 % 10);if (i >= 10) nlz[i][j++] = ('0' + i / 10 % 10);if (i >= 1) nlz[i][j++] = ('0' + i % 10);nlz[i][j++] = '\0';}}};class Coutstream {private:using u32 = uint32_t;using u64 = uint64_t;using MyType = Coutstream;static char Q[BUF_SIZE];static constexpr fastoutputtable tb = fastoutputtable();u32 p10[10], p = 0;u64 p10l[19];template <class T, class U>static void fil(T& m, U& l, U x) { m = l / x; l -= m * x; }public:void next_dig9(u32 x) {u32 y;fil(y, x, p10[6]);nextcstr(tb.lz[y]);fil(y, x, p10[3]);nextcstr(tb.lz[y]), nextcstr(tb.lz[x]);}void nextchar(char c) {Q[p++] = c;if (p == BUF_SIZE) fwrite(Q, p, 1, stdout), p = 0;}void nexteoln() { nextchar('\n'); }void nextcstr(const char *s) { while (*s) nextchar(*(s++)); }void nextU32(uint32_t x) {u32 y = 0;if (x >= p10[9]) {fil(y, x, p10[9]);nextcstr(tb.nlz[y]), next_dig9(x);}else if (x >= p10[6]) {fil(y, x, p10[6]);nextcstr(tb.nlz[y]);fil(y, x, p10[3]);nextcstr(tb.lz[y]), nextcstr(tb.lz[x]);}else if (x >= p10[3]) {fil(y, x, p10[3]);nextcstr(tb.nlz[y]), nextcstr(tb.lz[x]);}else if (x >= 1) nextcstr(tb.nlz[x]);else nextchar('0');}void nextI32(int32_t x) {if (x >= 0) nextU32(x);else nextchar('-'), nextU32((u32)-x);}void nextU64(uint64_t x) {u32 y = 0;if (x >= p10l[18]) {fil(y, x, p10l[18]);nextU32(y);fil(y, x, p10l[9]);next_dig9(y), next_dig9(x);}else if (x >= p10l[9]) {fil(y, x, p10l[9]);nextU32(y), next_dig9(x);}else nextU32(x);}void nextI64(int64_t x) {if (x >= 0) nextU64(x);else nextchar('-'), nextU64((u64)-x);}template <class T>void nextint(T x) {if (x < 0) nextchar('-'), x = -x;if (!(0 < x)) { nextchar('0'); return; }std::string buf;while (0 < x) {buf.push_back('0' + (int)(x % 10));x /= 10;}for (int i = (int)buf.size() - 1; i >= 0; --i) nextchar(buf[i]);}void writetofile(bool flush = false) {fwrite(Q, p, 1, stdout);if (flush) fflush(stdout);p = 0;}Coutstream() {Q[0] = 0;p10[0] = p10l[0] = 1;for (int i = 1; i <= 9; ++i) p10[i] = p10[i - 1] * 10;for (int i = 1; i <= 18; ++i) p10l[i] = p10l[i - 1] * 10;}~Coutstream() { writetofile(); }MyType& operator<<(int tg) { nextI32(tg); return *this; }MyType& operator<<(unsigned int tg) { nextU32(tg); return *this; }MyType& operator<<(long tg) { nextI64(tg); return *this; }MyType& operator<<(unsigned long tg) { nextU64(tg); return *this; }MyType& operator<<(long long tg) { nextI64(tg); return *this; }MyType& operator<<(unsigned long long tg) { nextU64(tg);  return *this; }MyType& operator<<(const std::string& tg) { nextcstr(tg.c_str()); return *this; }MyType& operator<<(const char *tg) { nextcstr(tg); return *this; }MyType& operator<<(char tg) { nextchar(tg); return *this; }template <class T>MyType& operator<<(const std::vector<T>& tg) {if (tg.size() > 0) {(*this) << tg[0];for (int i = 1; i < (int)tg.size(); ++i) nextchar(' '), (*this) << tg[i];}return *this;}} cout;char Cinstream::Q[BUF_SIZE];char Coutstream::Q[BUF_SIZE];template <long long m>struct modint {private:long long x;public:constexpr modint() noexcept { x = 0; }constexpr modint(const long long v) noexcept {if (v < 0) x = v % m + m;else x = v % m;}friend Coutstream &operator<<(Coutstream& os, const modint& b) { return os << b.x; }friend Cinstream &operator>>(Cinstream& is, modint& b) { return is >> b.x; }constexpr long long &val() noexcept { return x; }constexpr modint &operator++() { ++x; if (x == m) x = 0; return *this; }constexpr modint operator++(int) { modint res = *this; ++*this; return res; }	    constexpr modint &operator--() { if (x == 0) x = m; --x; return *this; }constexpr modint operator--(int) { modint res = *this; --*this; return res; }constexpr modint operator+() const { return *this; }constexpr modint operator-() const { return modint() - *this; }constexpr modint operator+(const modint rhs) const noexcept { return modint(*this) += rhs; }constexpr modint operator-(const modint rhs) const noexcept { return modint(*this) -= rhs; }constexpr modint operator*(const modint rhs) const noexcept { return modint(*this) *= rhs; }constexpr modint operator/(const modint rhs) const noexcept { return modint(*this) /= rhs; }constexpr modint &operator+=(const modint rhs) noexcept { x += rhs.x; if (x >= m) x -= m; return *this; }constexpr modint &operator-=(const modint rhs) noexcept { if (x < rhs.x) x += m; x -= rhs.x; return *this; }constexpr modint &operator*=(const modint rhs) noexcept { x = x * rhs.x % m; return *this; }constexpr modint &operator/=(const modint rhs) noexcept { return *this = *this * rhs.inv(); }constexpr bool operator==(const modint& rhs) const noexcept { return x == rhs.x; }constexpr bool operator!=(const modint& rhs) const noexcept { return x != rhs.x; }long long inv() const {long long a = x, b = m, u = 1, v = 0, t;while (b) {t = a / b;a -= t * b;u -= t * v;std::swap(a, b);std::swap(u, v);}u %= m;if (u < 0) u += m;return u;}modint pow(long long n) const {modint a = *this, res = 1;while (n) {if (n & 1) res *= a;a *= a;n >>= 1;}return res;}long long log(long long b) const {long long ok = m, ng = -1, mid;while (ok - ng > 1) {mid = (ok + ng) >> 1;if (mid * mid >= m) ok = mid;else ng = mid;}std::unordered_map<long long, long long> mp;long long a = x;for (long long r = 1;  r < ok; ++r) {if (!mp.count(a)) mp[a] = r;a = a * x % m;}long long xinv = pow(ok).inv().val();a = b;for (long long q = 0; q < ok; ++q) {if (a == 1 && q > 0) return q * ok;if (mp.count(a)) return q * ok + mp[a];a = a * xinv % m;}return -1;}};using mod998 = modint<998244353>;template <class S, auto op, auto e>class segmenttree {private:std::vector<S> dat;int n, sz;public:segmenttree() : segmenttree(0) {}explicit segmenttree(int _n) : segmenttree(std::vector<S>(_n, e())) {}explicit segmenttree(int _n, S i) : segmenttree(std::vector<S>(_n, i)) {}explicit segmenttree(const std::vector<S>& v) : n(v.size()) {sz = 1;while (sz < (int)v.size()) sz <<= 1;dat.assign(sz << 1, e());for (int i = 0; i < n; ++i) dat[sz + i] = v[i];for (int i = sz - 1; i >= 1; --i) dat[i] = op(dat[i << 1], dat[i << 1 | 1]);}void set(int pos, S x) {pos += sz;dat[pos] = x;while (pos > 1) {pos >>= 1;dat[pos] = op(dat[pos << 1], dat[pos << 1 | 1]);}}void add(int pos, S x) {pos += sz;dat[pos] += x;while (pos > 1) {pos >>= 1;dat[pos] = op(dat[pos << 1], dat[pos << 1 | 1]);}}void apply(int pos, S x, const std::function<S(S, S)>& f) {pos += sz;dat[pos] = f(x, dat[pos]);while (pos > 1) {pos >>= 1;dat[pos] = op(dat[pos << 1], dat[pos << 1 | 1]);}}S fold(int l, int r) const {l += sz, r += sz;S resl = e(), resr = e();while (l < r) {if (l & 1) resl = op(resl, dat[l++]);if (r & 1) resr = op(dat[--r], resr);l >>= 1, r >>= 1;}return op(resl, resr);}S all_fold() const { return dat[1]; }S operator[](int pos) { return dat[sz + pos]; }int max_right(int l, const std::function<bool(S)>& f) const {if (l == n) return n;l += sz;S t = e();do {while ((l & 1) == 0) l >>= 1;if (!f(op(t, dat[l]))) {while (l < sz) {l <<= 1;if (f(op(t, dat[l]))) t = op(t, dat[l++]);}return l - sz;}t = op(t, dat[l]);++l;} while ((l & -l) != l);return n;}int min_left(int r, const std::function<bool(S)>& f) const {if (r == 0) return 0;r += sz;S t = e();do {--r;while (r > 1 && (r & 1) == 0) r >>= 1;if (!f(op(dat[r], t))) {while (r < sz) {r = r << 1 | 1;if (f(op(dat[r], t))) t = op(dat[r--], t);}return r - sz + 1;}} while ((r & -r) != r);return 0;}};template <class S, auto op, auto e, class F, auto mapping, auto composition, auto id>class lazysegtree {private:std::vector<S> dat;std::vector<F> lazy;int n, sz, lg;void all_apply(int pos, F f) {dat[pos] = mapping(f, dat[pos]);if (pos < sz) lazy[pos] = composition(f, lazy[pos]);}void pushdown(int pos) {all_apply(pos << 1, lazy[pos]);all_apply(pos << 1 | 1, lazy[pos]);lazy[pos] = id();}void pushup(int pos) { dat[pos] = op(dat[pos << 1], dat[pos << 1 | 1]); }public:lazysegtree() : lazysegtree(std::vector<S>(0, e())) {}explicit lazysegtree(int n) : lazysegtree(std::vector<S>(n, e())) {}explicit lazysegtree(int n, S i) : lazysegtree(std::vector<S>(n, i)) {}explicit lazysegtree(const std::vector<S>& v) : n((int)v.size()) {sz = 1;while (sz < n) sz <<= 1;lg = __builtin_ctz((unsigned int)sz);dat.assign(sz << 1, e());lazy.assign(sz << 1, id());for (int i = 0; i < n; ++i) dat[i + sz] = v[i];for (int i = sz - 1; i >= 1; --i) pushup(i);}void set(int pos, S x) {pos += sz;for (int i = lg; i >= 1; --i) pushdown(pos >> i);dat[pos] = x;for (int i = 1; i <= lg; ++i) pushup(pos >> i);}void add(int pos, S x) {pos += sz;for (int i = lg; i >= 1; --i) pushdown(pos >> i);dat[pos] += x;for (int i = 1; i <= lg; ++i) pushup(pos >> i);}void apply(int pos, F f) {pos += sz;for (int i = lg; i >= 1; --i) pushdown(pos >> i);dat[pos] = mapping(f, dat[pos]);for (int i = 1; i <= lg; ++i) pushup(pos >> i);}void apply(int l, int r, F f) {if (l == r) return;	l += sz, r += sz;for (int i = lg; i >= 1; --i) {if (((l >> i) << i) != l) pushdown(l >> i);if (((r >> i) << i) != r) pushdown((r - 1) >> i);}{int l2 = l, r2 = r;while (l < r) {if (l & 1) all_apply(l++, f);if (r & 1) all_apply(--r, f);l >>= 1;r >>= 1;}l = l2;r = r2;}for (int i = 1; i <= lg; ++i) {if (((l >> i) << i) != l) pushup(l >> i);if (((r >> i) << i) != r) pushup((r - 1) >> i);}}S operator[](int pos) {pos += sz;for (int i = lg; i >= 1; --i) pushdown(pos >> i);return dat[pos];}S fold(int l, int r) {if (l == r) return e();l += sz, r += sz;for (int i = lg; i >= 1; --i) {if (((l >> i) << i) != l) pushdown(l >> i);if (((r >> i) << i) != r) pushdown((r - 1) >> i);}S resl = e(), resr = e();while (l < r) {if (l & 1) resl = op(resl, dat[l++]);if (r & 1) resr = op(dat[--r], resr);l >>= 1;r >>= 1;}return op(resl, resr);}S all_fold() { return dat[1]; }int max_right(int l, const std::function<bool(S)>& g) {if (l == n) return n;l += sz;for (int i = lg; i >= 1; --i) pushdown(l >> i);S t = e();do {while (!(l & 1)) l >>= 1;if (!g(op(t, dat[l]))) {while (l < sz) {pushdown(l);l <<= 1;if (g(op(t, dat[l]))) t = op(t, dat[l++]);}return l - sz;}t = op(t, dat[l]);++l;} while ((l & -l) != l);return n;}int min_left(int r, const std::function<bool(S)>& g) {if (r == 0) return 0;r += sz;for (int i = lg; i >= 1; --i) pushdown((r - 1) >> i);S t = e();do {--r;while (r > 1 && !(r & 1)) r >>= 1;if (!g(op(dat[r], t))) {if (r < sz) {pushdown(r);r = r << 1 | 1;if (g (op(dat[r], t))) t = op(dat[r--], t);}return r - sz + 1;}t = op(dat[r], t);} while ((r & -r) != r);return 0;}};class unionfind {private:std::vector<int> tree;public:explicit unionfind(int n = 0) : tree(n, -1) {}int root(int x) {int cur = x;while (tree[cur] >= 0) cur = tree[cur];int pos;while (tree[x] >= 0) {pos = x;x = tree[x];tree[pos] = cur;}return cur;}bool same(int u, int v) { return root(u) == root(v); }bool merge(int u, int v) {u = root(u), v = root(v);if (u == v) return false;if (u > v) std::swap(u, v);tree[u] += tree[v];tree[v] = u;return true;}int size(int x) { return -tree[root(x)]; }std::vector<std::vector<int>> groups() {std::vector<std::vector<int>> mem(tree.size()), res;for (int i = 0; i < (int)tree.size(); ++i) mem[root(i)].push_back(i);for (int i = 0; i < (int)tree.size(); ++i) {if (!mem[i].empty()) res.emplace_back(mem[i]);}return res;}};};using utility::cin, utility::cout, utility::modint, utility::mod998, utility::segmenttree, utility::lazysegtree, utility::unionfind, std::abs, std::sin, std::cos, std::tan, std::asin, std::acos, std::atan2, std::min, std::max, std::gcd, std::lcm, std::swap, std::pair, std::tuple, std::set, std::map, std::multiset, std::vector, std::string, std::queue, std::stack, std::priority_queue, std::deque, std::unordered_set, std::unordered_map, std::sort, std::reverse, std::lower_bound, std::upper_bound, std::function;template<class... Args>void input(Args&... args){(utility::cin>>...>>args);}void print(){utility::cout<<'\n';}template<class T,class... Args>void print(const T& a,const Args&... args){cout<<a;(cout<<...<<(cout<<' ',args));cout<<'\n';}void yn(bool f){utility::cout <<(f?"Yes\n":"No\n");}template<class T,class... Args>bool chmax(T& a,Args... b){bool res=false;for(auto i:{b...}){if(a<i)a=i,res=true;}return res;}template<class T,class... Args>bool chmin(T& a,Args... b){bool res=false;for(auto i:{b...}){if(a>i)a=i,res = true;}return res;}constexpr const int INF = 1e9;constexpr const long long LINF = 1e18;constexpr long long MOD = 998244353;
#define INT(...) int __VA_ARGS__; input(__VA_ARGS__);
#define LL(...) long long __VA_ARGS__; input(__VA_ARGS__);
#define MINT(...) utility::mod998 __VA_ARGS__; input(__VA_ARGS__);
#define STR(...) std::string __VA_ARGS__; input(__VA_ARGS__);
#define CHAR(...) char __VA_ARGS__; input(__VA_ARGS__);
#define DBL(...) double __VA_ARGS__; input(__VA_ARGS__);
#define VEC(T, name, size) std::vector<T>name(size); utility::cin>>name;
#define VV(T, name, h, w) std::vector<std::vector<T>>name(h,std::vector<T>(w)); utility::cin>>name;
